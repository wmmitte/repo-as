mvn compile -DSkipTests ; mvn spring-boot:run -DSkipTests

taskkill /F /IM java.exe
mvn clean install -DskipTests ; mvn spring-boot:run -DSkipTests

taskkill /F /IM node.exe # si claude dit addrinuse : ¬†Unable to connect to API (EADDRINUSE)

== POUR AUTORISER NPM
Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass #temporaire
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser #permanent
npm run dev 
===
Voici quelques regles que tu vas de voir savoir et note √ßa dans ta m√©moire pour t'en souvenir √† chaque contexte :
# Utilise toujours le fran√ßais tant que possible pour le nommage des noms des fonctions, des variables et aussi des colonnes dans les tables

# Les interfaces doivent √™tre mobiles firts, donc parfaitement responsives. l'application utitlise la librairies css "daysyUI" Donc il faut te baser sur √ßa.

=====
C'est un projet fait en microservices et ils se trouvent tous dans le dossier "D:\Binaries\repo-as\spring-microservice". 
- Le backend est fait avec du java spring boot
- le frontend se trouve dans le dossier "D:\Binaries\repo-as\spring-microservice\gateway\src\main\resources\frontend" et est fait avec du react. il fait partie du microservice "Gateway"
- l'authentification utilise keycloak (tu verras les configs dans le docker-compose.yml
- Toute l'infrastructure est pilot√© en utilisant docker / docker-compose. Le fichier docker-compose est situ√© √† "D:\Binaries\repo-as\docker-compose.yml".

Je veux tu stocke tout ceci en m√©moire pour ne pas te perdre, et ensuite tu analyse bien ce qui est d√©j√† fait dans le projet les diff√©rents microservices, le frontend (leur structuration, etc..) et ensuite tu sauvegarde ou documente le tout et enuite on va impl√©menter d'autres fonctionnalit√©s


==
MAIL 
 mail:
    host: mail.songotechnologies.com
    port: 587
    username: noreply@songotechnologies.com
    password: bQ6*uagUXnwV6JE
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          connectiontimeout: 5000
          timeout: 5000
          writetimeout: 5000

# Configuration de la v√©rification d'email
app:
  verification:
    token-expiration-hours: 72
    base-url: http://localhost:8090
  mail:
    from: noreplay@songotechnologies.com
    from-name: Plateforme Intermediation

====
POWERSHELL SCRIPT

Pour ex√©cuter le script PowerShell que j'ai cr√©√©, voici les √©tapes :

  Ex√©cution du Script

  Depuis l'invite de commandes Windows (CMD) :
  powershell -ExecutionPolicy Bypass -File "D:\Binaries\repo-as\check-keycloak-user.ps1"

  Ou depuis PowerShell directement :
  Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process
  .\check-keycloak-user.ps1

  Pr√©requis

  1. Keycloak doit √™tre d√©marr√© sur le port 8098
  2. Le script utilise les credentials admin par d√©faut :
    - Username: admin
    - Password: admin

  Modifier l'email √† v√©rifier

  Le script v√©rifie actuellement l'utilisateur anptic.gov.bf@gmail.com. Pour v√©rifier un autre utilisateur, modifiez la ligne 18 du script :

  $email = "anptic.gov.bf@gmail.com"  # ‚Üê Remplacez par l'email d√©sir√©

  Par exemple, pour v√©rifier l'utilisateur root :
  $email = "root@pitm.com"

  Ce que le script affiche

  Le script affiche :
  - ‚úÖ Informations de l'utilisateur (ID, username, email, nom, statut email v√©rifi√©)
  - ‚úÖ R√¥les Realm effectifs (hors r√¥les par d√©faut comme default-*, offline_*, uma_authorization)
  - ‚úÖ Groupes auxquels appartient l'utilisateur

  D'apr√®s l'ex√©cution pr√©c√©dente, l'utilisateur anptic.gov.bf@gmail.com poss√®de :
  - R√¥les : expert, utilisateur
  - Groupes : Expert
  - Email v√©rifi√© : Non (False)

===== SUITE COURS CLIENRS SCOPES

 mais dis moi pour les clients scopes la, ya un format pr√©deifini qu"on doit forcement respect√© pour le champ 'Token Claim
  Name' ?

‚óè Excellente question ! Non, il n'y a pas de format obligatoire absolu, mais il y a des conventions standards et des formats attendus par votre code.

  Conventions standards JWT

  1. Claims standards OAuth2/OIDC (r√©serv√©s)

  Ces claims ont des noms pr√©d√©finis par les sp√©cifications OAuth2/OIDC :
  - sub - Subject (ID utilisateur)
  - email - Email
  - name - Nom complet
  - given_name - Pr√©nom
  - family_name - Nom de famille
  - preferred_username - Username pr√©f√©r√©
  - iss - Issuer (√©metteur du token)
  - aud - Audience (destinataire)
  - exp - Expiration
  - iat - Issued At (date cr√©ation)

  üëâ Ces noms sont standards et ne doivent PAS √™tre modifi√©s

  2. Claims personnalis√©s (vous choisissez)

  Pour vos propres donn√©es, vous pouvez utiliser n'importe quel nom, mais certaines conventions existent :

  a) Structure plate (simple)

  {
    "email": "user@example.com",
    "mon_role": "expert",
    "ma_donnee": "valeur"
  }
  ‚úÖ Token Claim Name: mon_role, ma_donnee

  b) Structure imbriqu√©e (recommand√©e pour organiser)

  {
    "email": "user@example.com",
    "realm_access": {
      "roles": ["expert", "manager"]
    },
    "custom_data": {
      "department": "IT",
      "level": 5
    }
  }
  ‚úÖ Token Claim Name: realm_access.roles, custom_data.department

  La notation point√©e (realm_access.roles) cr√©e automatiquement la structure imbriqu√©e.

  Formats sp√©cifiques √† Keycloak

  Keycloak a des conventions recommand√©es (mais pas obligatoires) :

  1. R√¥les Realm

  Convention Keycloak : realm_access.roles
  {
    "realm_access": {
      "roles": ["expert", "manager", "rh"]
    }
  }

  2. R√¥les Client

  Convention Keycloak : resource_access.${client_id}.roles
  {
    "resource_access": {
      "pitm-auth-service": {
        "roles": ["admin", "user"]
      },
      "autre-client": {
        "roles": ["viewer"]
      }
    }
  }

  Le ${client_id} est une variable remplac√©e automatiquement par Keycloak.

  3. Groupes

  Convention Keycloak : groups
  {
    "groups": ["/Managers", "/Experts", "/RH"]
  }

  Pourquoi respecter certains formats ?

  Ce qui est CRITIQUE : Coh√©rence avec votre code

  Votre code s'attend √† trouver les r√¥les √† des endroits pr√©cis :

  Dans le Gateway (UserPropagationGatewayFilter.java:99-114)

  // Le code cherche ici :
  Object realmAccess = oidcUser.getClaim("realm_access");
  if (realmAccess instanceof Map) {
      Object realmRoles = ((Map<?, ?>) realmAccess).get("roles");
      // ...
  }

  Si vous mettez Token Claim Name = "mes_roles" au lieu de "realm_access.roles", le code ne trouvera rien ! ‚ùå

  Dans le Service Auth (AuthController.java:131-168)

  // Le code cherche aussi ici :
  Object resourceAccess = principal.getClaim("resource_access");
  if (resourceAccess instanceof Map) {
      Object clientResource = ((Map<?, ?>) resourceAccess).get("pitm-auth-service");
      // ...
  }

  Exemples de configurations valides

  ‚úÖ Configuration 1 : Suivre la convention Keycloak (recommand√©)

  Token Claim Name: realm_access.roles
  Le JWT contiendra :
  {
    "realm_access": {
      "roles": ["expert", "manager"]
    }
  }
  üëâ Avantage : Compatible avec tous les clients Keycloak, standard

  ‚úÖ Configuration 2 : Format personnalis√© (si vous adaptez le code)

  Token Claim Name: user_permissions.application_roles
  Le JWT contiendra :
  {
    "user_permissions": {
      "application_roles": ["expert", "manager"]
    }
  }
  üëâ Mais il faut adapter le code Java pour chercher √† cet endroit !

  ‚ùå Configuration incorrecte (ce qui s'est pass√© chez vous)

  Token Claim Name:  realm_access.roles
                    ‚Üë ESPACE ICI
  Le JWT contenait :
  {
    " realm_access": {
      "roles": ["expert"]
    }
  }
  üëâ Le code cherche realm_access mais trouve " realm_access" (avec espace) ‚Üí FAIL

  Variables sp√©ciales Keycloak

  Certaines variables sont remplac√©es dynamiquement :

  - ${client_id} ‚Üí Remplac√© par l'ID du client (ex: pitm-auth-service)
  - ${azp} ‚Üí Authorized party
  - ${username} ‚Üí Username de l'utilisateur

  Exemple :
  Token Claim Name: resource_access.${client_id}.roles
  Devient dans le JWT :
  {
    "resource_access": {
      "pitm-auth-service": {
        "roles": ["admin"]
      }
    }
  }

  R√®gles d'or

  1. ‚úÖ Utiliser les conventions Keycloak pour les r√¥les et groupes (plus facile √† maintenir)
  2. ‚úÖ Pas d'espaces avant ou apr√®s les noms de claims
  3. ‚úÖ Coh√©rence avec le code : si votre code cherche realm_access.roles, utilisez ce format
  4. ‚úÖ Documentation : si vous cr√©ez des claims personnalis√©s, documentez-les
  5. ‚ö†Ô∏è Ne pas modifier les claims standards (sub, email, name, etc.)

  Pour v√©rifier vos claims

  Vous pouvez toujours d√©coder un JWT pour voir exactement ce qu'il contient :

  Outil en ligne : https://jwt.io

  Ou utilisez le script PowerShell que j'ai cr√©√© :
  powershell -ExecutionPolicy Bypass -File "D:\Binaries\repo-as\decode-jwt-token.ps1"

  ---
  En r√©sum√© : Pas de format obligatoire absolu, mais votre code s'attend √† des formats sp√©cifiques. Il faut soit :
  - Suivre les conventions Keycloak (realm_access.roles, resource_access.${client_id}.roles)
  - Ou adapter votre code Java pour chercher vos claims personnalis√©s

  Est-ce que √ßa r√©pond √† votre question ? üòä

‚úª Cogitated for 39s